{"version":3,"file":"respoke-stats.min.js","sources":["plugins/respoke-stats/respoke-stats.js"],"names":["factory","define","amd","exports","require","respoke","MediaStats","params","format","report","aliases","Object","keys","forEach","oldName","name","newname","members","connection","foundIncomingNetworkPaths","foundOutgoingNetworkPaths","JSON","parse","stringify","cons","googChannelId","googLocalAddress","googRemoteAddress","googLocalCandidateType","googRemoteCandidateType","googReadable","googRtt","googTransportType","googWritable","localaudio","googCodecName","bytesSent","packetsSent","localvideo","remoteaudio","bytesReceived","packetsReceived","remotevideo","MediaStatsParser","startsWith","string","value","slice","length","initStats","sdp","pc","remoteDescription","localDescription","remote","local","side","rsdp","lines","split","mediaType","lineIndex","line","lbits","ssrc","substring","interestingStats","match","onStats","timer","setInterval","that","getStats","done","err","log","error","message","stack","statsInterval","warn","buildStats","rawStats","stats","results","result","allStats","state","iceGatheringState","icegatheringState","iceConnectionState","statType","eachStat","rule","filter","typeMatch","type","keyMatch","stat","key","timestamp","periodLength","oldStats","testInt","parseInt","isNaN","deltas","undefined","indexOf","charAt","toUpperCase","Class","className","peerConnection","interval","deferred","Q","defer","retVal","handlePromise","promise","onSuccess","onError","args","navigator","mozGetUserMedia","push","resolve","reject","Error","apply","stopStats","clearInterval"],"mappings":"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","sourcesContent":["/* global define: false, respoke: false */\n/**\n * Copyright (c) 2014, D.C.S. LLC. All Rights Reserved. Licensed Software.\n * @ignore\n */\n\n// UMD wrapper to provide support for CommonJS, AMD, and browser globals\n(function (factory) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(['respoke'], factory);\n    } else if (typeof exports === 'object') {\n        // Node/CommonJS\n        factory(require('respoke'));\n    } else {\n        // Browser globals\n        factory(respoke);\n    }\n}(function (respoke) {\n    \"use strict\";\n    /**\n     * A report containing statistical information about the flow of media with the latest live statistics.\n     *\n     * This is a **plugin** for respoke. To leverage it, include `<script src=\"https://cdn.respoke.io/respoke-stats.min.js\"></script>`.\n     *\n     * The plugin adds the methods `getStats()` and `stopStats()` to `respoke.Call`.\n     * \n     * ## Usage\n     * \n     * Once you have a `Call` instance after `endpoint.startCall()` or in the `client.on('call')` / `new Client({ onCall: yourCallHandler })` event listener:\n     * \n     * **using callbacks**\n     *      \n     *      call.getStats({\n     *          onStats: function continualStatsHandler(evt) { . . . },\n     *          onSuccess: yourOnSuccessHandler,\n     *          onError: yourOnErrorHandler \n     *      });\n     * \n     * **or using a promise**\n     * \n     *      call.getStats({\n     *          onStats: function continualStatsHandler(evt) { . . . },\n     *      }).done(onSuccess, onFailure);\n     * \n     * @class respoke.MediaStats\n     * @constructor\n     * @link https://cdn.respoke.io/respoke-stats.min.js\n     * @param {object} params\n     */\n    respoke.MediaStats = function (params) {\n        params = JSON.parse(JSON.stringify(params || {}));\n        /**\n         * Information about the connection.\n         * @memberof! respoke.MediaStats\n         * @type {object}\n         * @name connection\n         * @property {string} channelId - A string which identifies this media stream (which may contain several\n         * media stream tracks) to the browser.\n         * @property {boolean} foundIncomingNetworkPaths - Whether or not the ICE hole-punching process has found\n         * a suitable network path from the remote party to this client.\n         * @property {boolean} foundOutgoingNetworkPaths - Whether or not the ICE hole-punching process has found\n         * a suitable network path from this client to the remote party.\n         * @property {string} localHost - The local IP and port number of the media connection.\n         * @property {string} remoteHost - The remote IP and port number of the media connection.\n         * @property {string} localMediaPath - The type of network path the local media is taking to the remote\n         * party, one of \"local\", \"srflx\", \"prflx\", \"relay\".\n         * @property {string} remoteMediaPath - The type of network path the local media is taking to the remote\n         * party, one of \"local\", \"srflx\", \"prflx\", \"relay\".\n         * @property {string} roundTripTime - How long it takes media packets to traverse the network path.\n         * @property {string} transport - Whether the media is flowing via UDP or TCP\n         */\n        /**\n         * Information about the local audio stream track.\n         * @memberof! respoke.MediaStats\n         * @type {object}\n         * @name localaudio\n         * @property {string} audioInputLevel - Microphone volume.\n         * @property {string} codec - Audio codec in use.\n         * @property {string} totalBytesSent - Total number of bytes sent since media first began flowing.\n         * @property {string} periodBytesSent - Number of bytes sent since the last stats event.\n         * @property {string} totalPacketsSent - Total number of packets sent since media first began flowing.\n         * @property {string} periodPacketsSent - Number of packets sent since the last stats event.\n         * @property {string} transportId - The identifer of the media stream to which this media stream track belongs.\n         */\n        /**\n         * Information about the local video stream track.\n         * @memberof! respoke.MediaStats\n         * @type {object}\n         * @name localvideo\n         * @property {string} codec - Video codec in use.\n         * @property {string} totalBytesSent - Total number of bytes sent since media first began flowing.\n         * @property {string} periodBytesSent - Number of bytes sent since the last stats event.\n         * @property {string} totalPacketsSent - Total number of packets sent since media first began flowing.\n         * @property {string} periodPacketsSent - Number of packets sent since the last stats event.\n         * @property {string} transportId - The identifer of the media stream to which this media stream track belongs.\n         */\n        /**\n         * Information about the remote audio stream track.\n         * @memberof! respoke.MediaStats\n         * @type {object}\n         * @name remoteaudio\n         * @property {string} audioOutputLevel\n         * @property {string} totalBytesReceived - Total number of bytes received since media first began flowing.\n         * @property {string} periodBytesReceived - Number of bytes received since the last stats event.\n         * @property {string} packetsLost - Total number of packets lost.\n         * @property {string} totalPacketsReceived - Total number of packets received since media first began flowing.\n         * @property {string} periodPacketsReceived - Number of packets received since the last stats event.\n         * @property {string} transportId - The identifer of the media stream to which this media stream track\n         * belongs.\n         */\n        /**\n         * Information about the remote video stream track.\n         * @memberof! respoke.MediaStats\n         * @type {object}\n         * @name remotevideo\n         * @property {string} totalBytesReceived - Total number of bytes received since media first began flowing.\n         * @property {string} periodBytesReceived - Number of bytes received since the last stats event.\n         * @property {string} packetsLost - Total number of packets lost.\n         * @property {string} totalPacketsReceived - Total number of packets received since media first began flowing.\n         * @property {string} periodPacketsReceived - Number of packets received since the last stats event.\n         * @property {string} transportId - The identifer of the media stream to which this media stream track belongs.\n         */\n        /**\n         * Information about connection state.\n         * @memberof! respoke.MediaStats\n         * @type {object}\n         * @name state\n         * @property {string} iceConnectionState - Indicates where we are in terms of ICE network negotiation -- \"hole\n         * punching.\"\n         * @property {string} iceGatheringState - Indicates whether we have started or finished gathering ICE\n         * candidates from the browser.\n         */\n        /**\n         * The date and time at which this stats snapshot was taken.\n         * @memberof! respoke.MediaStats\n         * @name timestamp\n         * @type {date}\n         */\n        /**\n         * The time that has passed since the last stats snapshot was taken.\n         * @memberof! respoke.MediaStats\n         * @name periodLength\n         * @type {number}\n         */\n        /**\n         * These aliases define what things should be renamed before report is sent.\n         * @memberof! respoke.MediaStats\n         * @private\n         * @name aliases\n         * @type {object}\n         */\n        var aliases = {\n            cons: {\n                newname: 'connection',\n                members: {\n                    googChannelId: 'channelId',\n                    googLocalAddress: 'localHost',\n                    googRemoteAddress: 'remoteHost',\n                    googLocalCandidateType: 'localMediaPath',\n                    googRemoteCandidateType: 'remoteMediaPath',\n                    googReadable: 'foundIncomingNetworkPaths',\n                    googRtt: 'roundTripTime',\n                    googTransportType: 'transport',\n                    googWritable: 'foundOutgoingNetworkPaths'\n                }\n            },\n            localaudio: {\n                members: {\n                    googCodecName: 'codec',\n                    bytesSent: 'totalBytesSent',\n                    packetsSent: 'totalPacketsSent'\n                }\n            },\n            localvideo: {\n                members: {\n                    googCodecName: 'codec',\n                    bytesSent: 'totalBytesSent',\n                    packetsSent: 'totalPacketsSent'\n                }\n            },\n            remoteaudio: {\n                members: {\n                    googCodecName: 'codec',\n                    bytesReceived: 'totalBytesReceived',\n                    packetsReceived: 'totalPacketsReceived'\n                }\n            },\n            remotevideo: {\n                members: {\n                    googCodecName: 'codec',\n                    bytesReceived: 'totalBytesReceived',\n                    packetsReceived: 'totalPacketsReceived'\n                }\n            }\n        };\n\n        /**\n         * Rename report attributes to have more readable, understandable names.\n         * @memberof! respoke.MediaStats\n         * @method respoke.MediaStats.format\n         * @param {object} report\n         * @param {object} aliases\n         * @returns {object}\n         * @private\n         */\n        function format(report, aliases) {\n            Object.keys(aliases).forEach(function eachAttr(oldName) {\n                var name;\n                if (typeof aliases[oldName] === 'string') {\n                    report[aliases[oldName]] = report[oldName];\n                    delete report[oldName];\n                } else if (typeof aliases[oldName] === 'object') {\n                    name = oldName;\n                    if (aliases[oldName].newname) {\n                        report[aliases[oldName].newname] = report[oldName];\n                        name = aliases[oldName].newname;\n                        delete report[oldName];\n                    }\n                    if (aliases[oldName].members) {\n                        format(report[name], aliases[oldName].members);\n                    }\n                }\n            });\n\n            if (report.connection) {\n                report.connection.foundIncomingNetworkPaths = ('true' === report.connection.foundIncomingNetworkPaths);\n                report.connection.foundOutgoingNetworkPaths = ('true' === report.connection.foundOutgoingNetworkPaths);\n            }\n            return report;\n        }\n        return format(params, aliases);\n    }; // End respoke.MediaStats\n\n    /**\n     * A handler for WebRTC statistics. This class takes an `onStats` callback which it calls every `interval` seconds\n     * with the latest live statistics.\n     * @class respoke.MediaStatsParser\n     * @private\n     * @constructor\n     * @augments respoke.Class\n     * @param {RTCPeerConnection} peerConnection\n     */\n    respoke.MediaStatsParser = function (params) {\n        params = params || {};\n        var that = respoke.Class(params);\n        /**\n         * @memberof! respoke.MediaStatsParser\n         * @name className\n         * @type {string}\n         */\n        that.className = 'respoke.MediaStatsParser';\n        /**\n         * @memberof! respoke.MediaStatsParser\n         * @private\n         * @name oldStats\n         * @type {boolean}\n         */\n        var oldStats = false;\n        /**\n         * @memberof! respoke.MediaStatsParser\n         * @private\n         * @name pc\n         * @type RTCPeerConnection\n         */\n        var pc = params.peerConnection;\n        delete params.peerConnection;\n        /**\n         * @memberof! respoke.MediaStatsParser\n         * @private\n         * @name timer\n         * @type {number}\n         * @desc The timer for calling the onStats callback; the output of setInterval.\n         */\n        var timer = 0;\n        /**\n         * @memberof! respoke.MediaStatsParser\n         * @private\n         * @name statsInterval\n         * @type {number}\n         * @desc The millisecond interval on which we call the onStats callback.\n         */\n        var statsInterval = params.interval || 5000;\n\n        /*\n         * The data you get out of getStats needs some pruning and a tidy up\n         * so I define some things I think are 'interesting' and how to find them.\n         *\n         * getStats gives you an array of results each of which has a type.\n         * Each result contains a list of keys and a dictionary of values that can\n         * be retrieved by key. (no ,they aren't properties)\n         *\n         * The interesting stats object is a list of objects, each describing the\n         * type of result that contains the stats, the names of the relevant stats\n         * and a way to filter out the irrelevant results objects of the same type.\n         *\n         * An added complication is that the standards are in flux so google add\n         * data in chrome (some of it useful) that isn;t in the draft standard.\n         */\n\n        /**\n         * @memberof! respoke.MediaStatsParser\n         * @private\n         * @name interestingStats\n         * @type {object}\n         */\n        var interestingStats = {\n            cons: {\n                type: \"googCandidatePair\",\n                match: {key: \"googActiveConnection\", value: \"true\"},\n                keys: [\n                    \"googWritable\", \"googReadable\", \"googTransportType\", \"googLocalCandidateType\",\n                    \"googRemoteCandidateType\", \"googRemoteAddress\", \"googLocalAddress\", \"googRtt\", \"googChannelId\"\n                ]\n            },\n            // the next 4 property names _matter_ they have to finish with the value of an m= line\n            // if you change them things won't work.\n            localaudio: {\n                type: \"ssrc\",\n                match: {key: \"ssrc\", value: \"\"},\n                keys: [\"audioInputLevel\", \"packetsSent\", \"bytesSent\", \"transportId\", \"googCodecName\"]\n            },\n            remoteaudio: {\n                type: \"ssrc\",\n                match: {key: \"ssrc\", value: \"\"},\n                keys: [\"audioOutputLevel\", \"packetsReceived\", \"packetsLost\", \"bytesReceived\", \"transportId\"]\n            },\n            remotevideo: {\n                type: \"ssrc\",\n                match: {key: \"ssrc\", value: \"\"},\n                keys: [\"packetsReceived\", \"packetsLost\", \"bytesReceived\", \"transportId\"]\n            },\n            localvideo: {\n                type: \"ssrc\",\n                match: {key: \"ssrc\", value: \"\"},\n                keys: [\"packetsSent\", \"bytesSent\", \"transportId\", \"googCodecName\"]\n            }\n        };\n\n        /**\n         * @memberof! respoke.MediaStatsParser\n         * @private\n         * @name deltas\n         * @type {object}\n         */\n        var deltas = {\n            packetsSent: true,\n            bytesSent: true,\n            packetsReceived: true,\n            bytesReceived: true\n        };\n\n        /**\n         * Determine if a string starts with the given value.\n         * @memberof! respoke.MediaStatsParser\n         * @method respoke.MediaStatsParser.startsWith\n         * @param {string} string\n         * @param {string} value\n         * @returns {boolean}\n         * @private\n         */\n        function startsWith(string, value) {\n            return (string && string.slice && (string.slice(0, value.length) === value));\n        }\n\n        /**\n         * Parse the SDPs. Kick off continuous calling of getStats() every `interval` milliseconds.\n         * @memberof! respoke.MediaStatsParser\n         * @method respoke.MediaStatsParser.initStats\n         * @private\n         */\n        function initStats() {\n            var sdp = {};\n            if (!pc || !pc.remoteDescription || !pc.remoteDescription.sdp ||\n                !pc.localDescription || !pc.localDescription.sdp) {\n                respoke.log.warn(\"missing info.\");\n                return;\n            }\n\n            sdp = {\n                remote: pc.remoteDescription.sdp,\n                local: pc.localDescription.sdp\n            };\n\n            /**\n             * extract the ssrcs from the sdp, because it isn't anwhere else.\n             * we will use them to map results to audio/video etc\n             */\n            Object.keys(sdp).forEach(function eachKey(side) {\n                var rsdp = sdp[side];\n                // filet the sdp\n                var lines = rsdp.split(\"\\r\\n\");\n                var mediaType = null;\n\n                Object.keys(lines).forEach(function lineNum(lineIndex) {\n                    var line = lines[lineIndex];\n                    var lbits = null;\n                    var ssrc = null;\n\n                    if (startsWith(line, \"m=\")) { // take a note of the sort of media we are looking at\n                        mediaType = line.substring(2, 7); // should be either 'audio' or 'video'\n                    } else if (startsWith(line, \"a=ssrc:\")) {\n                        lbits = line.split(\" \");\n                        ssrc = lbits[0].substring(\"a=ssrc:\".length);\n\n                        if (interestingStats[side + mediaType]) {\n                            // fill in the value of the respective 'match'\n                            // build the name of the stat from parts\n                            interestingStats[side + mediaType].match.value = ssrc;\n                        }\n                    }\n                });\n            });\n\n            if (params.onStats) {\n                timer = setInterval(function statsTimerHandler() {\n                    that.getStats().done(params.onStats, function errorHandler(err) {\n                        respoke.log.error(\"error in getStats\", err.message, err.stack);\n                    });\n                }, statsInterval);\n            } else {\n                respoke.log.warn(\"Not starting stats, no onStats callback provided.\");\n            }\n        }\n\n        /**\n         * Get one snapshot of stats from the call's PeerConnection.\n         * @memberof! respoke.MediaStatsParser\n         * @method respoke.MediaStatsParser.getStats\n         * @param {object} [params]\n         * @param {respoke.MediaStatsParser.statsHandler} [params.onSuccess] - Success handler for this\n         * invocation of this method only.\n         * @param {respoke.Client.errorHandler} [params.onError] - Error handler for this invocation of this\n         * method only.\n         * @param {respoke.MediaStatsParser.statsHandler} [params.onStats] - Callback accepting a single `event` argument.\n         * @returns {Promise<object>|undefined}\n         */\n        that.getStats = function (params) {\n            params = params || {};\n            var deferred = respoke.Q.defer();\n            var retVal = respoke.handlePromise(deferred.promise, params.onSuccess, params.onError);\n            var args = [];\n\n            if (!pc.getStats) {\n                deferred.reject(new Error(\"no peer connection getStats()\"));\n                return retVal;\n            }\n\n            if (navigator.mozGetUserMedia) {\n                args.push(null);\n            }\n\n            args.push(function successHandler(stats) {\n                deferred.resolve(respoke.MediaStats(buildStats(stats)));\n            });\n            args.push(function errorHandler(err) {\n                respoke.log.error(err);\n                deferred.reject(new Error(\"Can't get stats.\"));\n            });\n            pc.getStats.apply(pc, args);\n            return retVal;\n        };\n\n        /**\n         * Stop fetching and processing of call stats.\n         * @memberof! respoke.MediaStatsParser\n         * @method respoke.MediaStatsParser.stopStats\n         */\n        that.stopStats = function () {\n            clearInterval(timer);\n        };\n\n        /**\n         * Receive raw stats and parse them.\n         * @memberof! respoke.MediaStatsParser\n         * @method respoke.MediaStatsParser.buildStats\n         * @param {object} rawStats\n         * @private\n         */\n        function buildStats(rawStats) {\n            // extract and repackage 'interesting' stats using the rules above\n            var stats = rawStats; // might need to re-instate some sort of wrapper here\n            var results = stats.result();\n\n            var allStats = {\n                state: {\n                    iceGatheringState: pc.icegatheringState,\n                    iceConnectionState: pc.iceConnectionState\n                }\n            };\n\n            Object.keys(interestingStats).forEach(function eachStatType(statType) {\n                var eachStat = {};\n                var rule = interestingStats[statType];\n                var report = results.filter(function eachResult(result) {\n                    var typeMatch = (result.type === rule.type);\n                    var keyMatch = (result.stat(rule.match.key) === rule.match.value);\n                    return (typeMatch && keyMatch);\n                });\n\n                if (report.length > 0) {\n                    if (report[0].timestamp) {\n                        allStats.timestamp = report[0].timestamp;\n                        allStats.periodLength = allStats.timestamp - oldStats.timestamp;\n                    }\n                    rule.keys.forEach(function eachKey(key) {\n                        var testInt = parseInt(report[0].stat(key), 10);\n                        if (!isNaN(testInt)) {\n                            eachStat[key] = testInt;\n                        } else {\n                            eachStat[key] = report[0].stat(key);\n                        }\n\n                        if (deltas[key] && oldStats && oldStats[statType] &&\n                            [null, undefined].indexOf(oldStats[statType][key]) === -1) {\n                            eachStat[\"period\" + key.charAt(0).toUpperCase() + key.slice(1)] =\n                                (eachStat[key] - oldStats[statType][key]);\n                        }\n                    });\n                }\n                allStats[statType] = eachStat;\n            });\n            oldStats = allStats;\n            return allStats;\n        }\n\n        initStats();\n\n        return that;\n    }; // End respoke.MediaStatsParser\n}));\n\n/**\n * Success handler for methods that generate stats.\n * @callback respoke.MediaStatsParser.statsHandler\n * @param {respoke.MediaStats}\n */\n"]}